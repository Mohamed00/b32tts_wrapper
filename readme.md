# b32_wrapper

## What is this?
In late 2024, someone who goes by rommix0 introduced the blind community to a windows x86 version of the ancient yet saught after Keynote Gold speech synthesis engine.

Unfortunately, this version of the synthesizer came with the one major flaw that it's only output method was via the Win32 WaveOut API. This means that you couldn't use this to, for example, synthesize speech to a wave file, add effects to the output etc.

This project negates the aformentioned issue by actually hooking the waveOut functions and capturing the audio output sent to them, building it into a single, easily accessible memory buffer.

## How to build?
This project uses the SCons build system. If you have scons installed, you can just run scons -s in the root of this project to generate a .dll wrapper, a test program and a statically linked high level command line utility.

## How to use?

### Command line utility
If you just want to speak text out loud or to a file, you are likely going to be much more interested in the high level command line utility created from this wrapper instead of the wrapper's API itself. After downloading a binary release or building the project from source, you will see the file bin/bspk.exe. You can run bspk -h for the most up-to-date help on the program.

In short, the accepted switches are -v to select a voice, -t to set text to speak, -f to set an output filename and -r to set the speech rate.

For example,

```bspk -ftts.wav -vHary -t"Hi there, my name is Hary!"```

You can set the voice to a single questionmark (?) to list available voices. For example, ```bspk -v?```

### API
The main thing to note is that the dll generated by this project, b32_wrapper.dll, should be loaded and used in place of b32_tts.dll which this wrapper will handle internally.

The interface is only composed of 5 functions:


```const char** bst_voices(int* count = nullptr);```

You can call this function to get a list of supported voice names. These are actually entirely defined by this wrapper as a bonus, using values provided by @rommix0's BST.h file. The result is a null terminated array of null terminated c strings.


```bst_state* bst_init(const char* module_path = "b32_tts.dll");```

```bst_state* bst_init_w(const wchar_t* module_path = L"b32_tts.dll");```

Call this function to initialize an instance of the tts engine and associated wrapper. The module_path argument can be set to any valid relative or absolute path to b32_tts.dll, which will be internally loaded upon a call to this function.


```void bst_free(bst_state* s);```

Call this function when you are done using the engine.


```char* bst_speak(bst_state* s, long* size, char* text, int voice = 0, int rate = 0, int gain = 0, bool pcm_header = true);```

The main attraction as it were, this function converts a string of text to a byte array of pcm audio data using the bestspeech engine. The size argument should point to an integer that will be filled with the number of bytes returned. The voice argument can be >=0 to use a builtin voice (call bst_voices for a list), or a negative value to pass the text string to the synthesizer verbatim. Rate can be >0 to speed up, <0 to slow down. I believe gain is in db. If pcm_header is set to false, the 44 byte RIFF header will be omited from the output. Free return values with bst_free.


```void bst_speech_free(char* text);```

Call this to free any data returned by bst_speak.


## Notes
* This has not been tested in a multithreaded conntext. It's probably best to create a new bst_state for each thread.
* Currently, a reallocation is performed each time bestspeech provides a new audio buffer. This wrapper could probably be made more performant by improving it's memory allocation.
* We also currently use the win32 SetTimer API to release buffers when we're done with them. This wrapper could probably be made more performant by replacing that logic with our own thread that frees buffers and posts a message to the GUI thread faster than SetTimer and it's associated USER_TIMER_MINIMUM limitation.
* If you want to build the wrapper statically, make sure to define b32w_export to an empty value on the compiler command line so that the dllexport attribute won't be applied to the wrapper's functions, and make sure to link with bin/MinHook.lib in that case.
* I did try to be careful here and make sure that the waveout hooks won't interfear with any other genuine usage of waveout in programs that use this wrapper. This is acomplished in 2 ways, first by leaving all API hooks disabled until right at the moment of synthesis then disabling them again the moment synthesis is complete, and also with a thread_local check that should passthrough any hooked waveout calls on threads other than the one invoking the tts engine.
